% This script will do some of the AfNI preprocessing for me, at least as I
% learn how to use AfNI.  I'm going to set it up to be a bit dumb
% initially, then modify it to work more flexibly later.
%
% A quick guide to the EPI filenames associated with different
% preprocessing steps:
% 1) *_preTshift.nii.gz: the first .nii file, generated by DICOM conversion
% 2) *_Tshift.nii.gz: the result of slice timing correction performed on
%       the *_preTshift.nii.gz files.  This file is then de-obliqued
%       & overwritten.
% 3) *_Tshift-LPI.nii.gz: this file is produced transiently when the
%       de-obliqued file is resampled to LPI space.
% 4) *.nii.gz: this file results from a Unix "mv" command that simply
%       changes the name of *_Tshift-LPI.nii.gz.
% 5) *_Mean.nii.gz: the mean epi taken from the first set of epis obtained
%       during the experiment.
% 6) *_Mask.nii.gz: the epi mask derived from the mean epi.
% 7) *_CoReg.nii.gz: after *.nii.gz and *_Mean.nii.gz files are produced,
%       this file results from the realignment of the epis.
% 8) *_Smooth.nii.gz: coregistered files are then smoothed to generate 
%       this file type.
%
% Ancillary EPI-related files:
% 1) *_epiparams.mat: a mat-file containing the header-extracted number of
%       slices, number of time points collected, and the TR
% 2) *_tpattern.txt: a text file with the calculated slice offset timing
% 3) *_1D.txt: the file containing subject movement parameters
% 4) *_MD1D.txt: contains the maximal displacment related to subject
%       movement at each time point
% 5) *_outcount.txt: the number of outlier voxels in the automasked EPI
%       volume at each time point
% 6) *_qual.txt: the correlation of each EPI volume with the 
% 7) *_datacheck.jpg: images containing the *_outcount.txt, *_qual.txt, and
%       *_1D.txt timecourses --> essentially, a data quality image file
%
% A quick guide to the anatomical files:
% 1) *_mprage.nii.gz: the first .nii file, generated by DICOM conversion
% 2) *_mprage-LPI.nii.gz: a transient file that overwrites *_mprage.nii.gz
% 3) *_mprage_Cut.nii.gz: identical to the _mprage.nii.gz file, EXCEPT that
%       the file holds only a subset (typically 80-240) of the slices
% 4) *_mprage_Cut-LPI.nii.gz: again, a transient file that overwrites its
%       parent file
% 5) *_mprage_AlignEpi.nii.gz: this file holds the anatomical image that is
%       aligned to the mean epi
% 6) *_mprage_MNI.nii.gz: the normalized version of the AlignEpi.nii.gz 
%       anatomical file.
%
% Ancillary anatomical files:
% 1) *_mprage_Cut_1D.txt: holds a transformation matrix that aligns the
%       *_mprage_Cut.nii.gz file to the epis
% 2) *_flirt.txt: contains the linear transformation matching the subject's
%       EPI-aligned anatomical to the MNI template.
% 3) *_fnirt.nii.gz: contains the nonlinear transformation matching the
%       subject's EPI-aligned anatomical to the MNI template.


format compact;
main_dir = '/home/despo/BMI_dopa/TBP/subjects/';
script_dir = [main_dir, 'Scripts/Andy/'];
data_dir = [main_dir 'Data/'];
template_dir = [main_dir, 'Scripts/Andy/Templates/'];
addpath(script_dir, [script_dir 'Nifti_Functions/']);

disp(' ');
disp(' *** PLEASE DO NOT PREPROCESS sessions 2 & 3 prior ***');
disp(' ***            to running session 1.              ***');
disp(' ');

rest_runs = 2;
rest_len = 280;
task_runs = 6;
task_len = 300;
food_runs = 3;
food_len = 385;
d_temp = dir(data_dir);
count = 0;
for l1 = 1:length(d_temp)
    if length(d_temp(l1).name) == 4 && d_temp(l1).name(1) == '7' && ...
              str2num(d_temp(l1).name(4)) <= 3
        count = count+1;
        d(count) = d_temp(l1);
    end
end
clear d_temp temp_int;
disp(' ');
disp('Possible Subjects:');
for l1 = 1:length(d)
    disp(['  ', int2str(l1), ') ', d(l1).name]);
end
sidx = -1;
while sidx < 1 || sidx > length(d)
    sidx = input('Number of subject to analyze: ');
end
disp(' ');
subj_dir = [data_dir d(sidx).name '/'];

% d_temp = dir([subj_dir '2012*']);
% if isempty(d_temp) || length(d_temp) > 1
%     disp('   *** No single date-labeled directory found ***');
%     return;
% else
%     subj_dir = [subj_dir d_temp(1).name '/'];

dicom_dir = [subj_dir 'DICOMS/'];
diary([subj_dir d(sidx).name '_diary_' date]);

% end
% clear d_temp;


% First convert dicoms to Nifti format
convert_anat = 'x';
anat_dir = [subj_dir 'Anatomy/'];
anat_prefix = [d(sidx).name '_mprage.nii.gz'];
session = str2num(d(sidx).name(4));
if session ~= 1
    disp(' ');
    disp(['Selected preprocessing files are for session ' int2str(session)]);
    usesession1 = 'x';
    while usesession1 ~= 'n' && usesession1 ~= 'y'
        usesession1 = input('In later steps, would you like to realign all files to session 1 (y/n) ?  ','s');
    end
end
if session ~= 1         % Get first session's anatomy directory as a potential reference
    temp_anat_dir = [data_dir d(sidx).name(1:3) '1/'];
    % d_temp = dir([temp_anat_dir '2012*']);
    % anat_ref_dir = [temp_anat_dir d_temp(1).name '/Anatomy/'];
    anat_ref_dir = [temp_anat_dir 'Anatomy/'];
    anat_ref_prefix = [d(sidx).name(1:3) '1_mprage_AlignEpi.nii.gz'];
    epi_mean_ref_prefix = [d(sidx).name(1:3) '1_Mean.nii.gz'];
    epi_mask_ref_prefix = [d(sidx).name(1:3) '1_Mask.nii.gz'];
end

anat_filename = [anat_dir, anat_prefix];
adir_exist = exist(anat_dir);
if adir_exist ~= 7
    unix(['mkdir ', anat_dir]);
    convert_anat = 'y';
else
    if exist(anat_filename) ~= 2
        convert_anat = 'y';
    else
        disp(['*** CAUTION: The file ', anat_filename, ' exists. ***']);
        while convert_anat ~= 'y' && convert_anat ~= 'n'
            convert_anat = input('  Delete previous anatomical images (y/n) ?  ','s');
        end
        if convert_anat == 'y'
            unix(['rm ' anat_filename]);
        end
    end
end
if convert_anat == 'y'
    currdir = pwd;
    cd(anat_dir);
    d_mprage = dir([dicom_dir, '*mprage*']);
    if ~isempty(dir([dicom_dir d_mprage(1).name '/*gz']))
        disp('Unzipping dicom images.');
        unix(['gunzip ' dicom_dir d_mprage(1).name '/*gz']);
    end
    command = ['to3d -anat -datum float -prefix ' anat_prefix ' ' ...
                dicom_dir d_mprage(1).name '/*.dcm'];
    disp(['EXECUTING: ', command]);
    unix(command);
    command = ['3drefit -deoblique -xorigin cen -yorigin cen -zorigin cen ' ...
                anat_prefix];
    disp(['EXECUTING: ', command]);
    unix(command);
    command = ['3dresample -orient LPI -prefix ' anat_prefix(1:end-7) ...
                '-LPI.nii.gz -inset ' anat_prefix];
    disp(['EXECUTING: ', command]);
    unix(command);
    
    unix(['mv ' anat_prefix(1:end-7) '-LPI.nii.gz ' anat_prefix]);
    
    if session ~= 1
        unix(['ln -s ' anat_ref_dir anat_ref_prefix]);
    end
    unix(['gzip ' dicom_dir d_mprage(1).name '/*dcm']);
    cd(currdir);
end
clear adir_exist anat_filename anat_prefix convert_anat currdir d_mprage;

% Next convert EPIs to Nifti format
convert_epi = 'x';
func_dir = [subj_dir, 'Functional/'];
fdir_exist = exist(func_dir);
if fdir_exist ~= 7
    unix(['mkdir ', func_dir]);
    convert_epi = 'y';
else
    d_func = dir(func_dir);
    if isempty(d_func)
        convert_epi = 'y';
    else
        disp(['*** CAUTION: Functional directories already exist. ***']);
        while convert_epi ~= 'y' && convert_epi ~= 'n'
            convert_epi = input('  Delete previous functional directories (y/n) ?  ','s');
        end
        if convert_epi == 'y'
            areyousure = 'x';
            while areyousure ~= 'y' && areyousure ~= 'n'
                areyousure = input('  --> Are you sure (y/n) ?  ','s');
            end
            if areyousure == 'y'
                unix(['rm -R ' func_dir]);
                unix(['mkdir ' func_dir]);
            else
                convert_epi = 'n';
            end
            clear areyousure;
        end
    end
end

if convert_epi == 'y'
    if ~isempty(dir([dicom_dir 'EPI*']))    % Rename EPI directories
        d_rest = dir([dicom_dir '*est*']);  % R may be capitalized or not
        if length(d_rest) ~= rest_runs
            for l1 = 1:length(d_rest)
                num_images(l1) = length(dir([dicom_dir d_rest(l1).name '/IM*dcm'])) + ...
                                 length(dir([dicom_dir d_rest(l1).name '/IM*dcm.gz']));
            end
            badones = find(num_images ~= rest_len);
            for l1 = 1:length(badones)
                disp(['    --> only ' int2str(num_images(badones(l1))) ' images; not reconstructing ' d_rest(badones(l1)).name]);
                unix(['mv ' dicom_dir d_rest(badones(l1)).name ' ' dicom_dir 'BAD_' d_rest(badones(l1)).name]); 
            end
            goodones = setdiff([1:length(d_rest)], badones);
            d_rest = d_rest(goodones);
            clear num_images badones goodones;
        end
        for l1 = 1:length(d_rest)
            uline = find(d_rest(l1).name == '_');
            dir_num(l1) = str2num(d_rest(l1).name(uline(end)+1:end));
        end
        [a,b] = sort(dir_num);
        for l1 = 1:length(b)
            d_rest(b(l1)).name_old = d_rest(b(l1)).name;
            d_rest(b(l1)).name = [d(sidx).name '_rest_' int2str(l1)];
            unix(['mv ' dicom_dir d_rest(b(l1)).name_old ' ' dicom_dir d_rest(b(l1)).name]);
        end
        clear dir_num a b;
        
        d_task = dir([dicom_dir '*ask*']);  % T may be capitalized or not
        if length(d_task) ~= task_runs
            for l1 = 1:length(d_task)
                num_images(l1) = length(dir([dicom_dir d_task(l1).name '/IM*dcm'])) + ...
                                 length(dir([dicom_dir d_task(l1).name '/IM*dcm.gz']));
            end
            badones = find(num_images ~= task_len);
            for l1 = 1:length(badones)
                disp(['    --> only ' int2str(num_images(badones(l1))) ' images; not reconstructing ' d_task(badones(l1)).name]);
                unix(['mv ' dicom_dir d_task(badones(l1)).name ' ' dicom_dir 'BAD_' d_task(badones(l1)).name]); 
            end
            goodones = setdiff([1:length(d_task)], badones);
            d_task = d_task(goodones);
            clear num_images badones goodones;
        end
        for l1 = 1:length(d_task)
            uline = find(d_task(l1).name == '_');
            dir_num(l1) = str2num(d_task(l1).name(uline(end)+1:end));
        end
        [a,b] = sort(dir_num);
        for l1 = 1:length(b)
            d_task(b(l1)).name_old = d_task(b(l1)).name;
            d_task(b(l1)).name = [d(sidx).name '_ddt_' int2str(l1)];
            unix(['mv ' dicom_dir d_task(b(l1)).name_old ' ' dicom_dir d_task(b(l1)).name]);
        end
        clear dir_num a b;
                
        d_food = dir([dicom_dir '*ood*']);  % F may be capitalized or not
        if length(d_food) ~= food_runs
            for l1 = 1:length(d_food)
                num_images(l1) = length(dir([dicom_dir d_food(l1).name '/IM*dcm'])) + ...
                                 length(dir([dicom_dir d_food(l1).name '/IM*dcm.gz']));
            end
            badones = find(num_images ~= task_len);
            for l1 = 1:length(badones)
                disp(['    --> only ' int2str(num_images(badones(l1))) ' images; not reconstructing ' d_food(badones(l1)).name]);
                unix(['mv ' dicom_dir d_food(badones(l1)).name ' ' dicom_dir 'BAD_' d_food(badones(l1)).name]); 
            end
            goodones = setdiff([1:length(d_food)], badones);
            d_food = d_food(goodones);
            clear num_images badones goodones;
        end
        for l1 = 1:length(d_food)
            uline = find(d_food(l1).name == '_');
            dir_num(l1) = str2num(d_food(l1).name(uline(end)+1:end));
        end
        [a,b] = sort(dir_num);
        for l1 = 1:length(b)
            d_food(b(l1)).name_old = d_food(b(l1)).name;
            d_food(b(l1)).name = [d(sidx).name '_food_' int2str(l1)];
            unix(['mv ' dicom_dir d_food(b(l1)).name_old ' ' dicom_dir d_food(b(l1)).name]);
        end
        clear dir_num a b;
    else
        d_rest = dir([dicom_dir '*_rest_*']);
        d_task = dir([dicom_dir '*_ddt_*']);
        d_food = dir([dicom_dir '*_food_*']);
    end
    d_epi = [d_food; d_task; d_rest];   % This order is important for defining mean epi later on
    clear d_rest d_food d_ddt1 d_ddt2;
    for l1 = 1:length(d_epi)
        % runidx = strfind(d_epi(l1).name, 'TR');     % Expects names of format 'EPI9613TR4Task_18'
        % ulineidx = find(d_epi(l1).name == '_');
        % run_info = d_epi(l1).name(runidx+2:ulineidx(end)-1);
        % run_type{l1} = run_info(find(isletter(run_info)));
        % run_num{l1} = run_info(find(~isletter(run_info)));
        % run_order(l1) = str2num(d_epi(l1).name(ulineidx(end)+1:end));
        currdir = pwd;
        % this_func_dir = [func_dir run_type{l1} run_num{l1} '/'];
        % unix(['mkdir ' this_func_dir]);
        % cd(this_func_dir);
        cd(func_dir);
        
        this_epidir = [dicom_dir d_epi(l1).name '/'];
        d_this_epidir = dir([this_epidir 'IM*dcm']);
        if isempty(d_this_epidir)
            unix(['gunzip ' this_epidir '*.gz']);
            d_this_epidir = dir([this_epidir 'IM*dcm']);
        end
        [num_slices, num_tps, TR, tpattern] = DICOM_EPI_info([this_epidir d_this_epidir(1).name]);
        save([d_epi(l1).name '_epiparams'], 'num_slices', 'num_tps', 'TR');
        tpattern_filename = [d_epi(l1).name '_tpattern.txt'];
        fid = fopen(tpattern_filename, 'w');
        for l2 = 1:length(tpattern)
            dummy = fprintf(fid, '%4d\n', tpattern(l2));
        end
        fclose(fid);
        
        epi_prefix = d_epi(l1).name;    % [d(sidx).name '_' run_type{l1} run_num{l1}];
        epi_prefix1 = [epi_prefix '_preTshift'];
        %command = ['to3d -epan -skip_outliers -assume_dicom_mosaic -datum float -time:zt 24 350 1370 @528B_Rest2_tpattern.txt -prefix 528B_Rest2_preTshift.nii.gz /home/Tolcapone/528B/DICOM/EPI9613TR2Rest_24/*.dcm'];
        command = ['to3d -epan -skip_outliers -assume_dicom_mosaic -datum float '...
                   '-time:zt ' int2str(num_slices) ' ' int2str(num_tps) ' ' ...
                   num2str(TR) ' @' tpattern_filename ' -prefix ' epi_prefix1 ...
                   '.nii.gz ' this_epidir '*.dcm'];
                   % num2str(TR) ' alt+z2 -prefix ' epi_prefix ' ' this_epidir '*.dcm'];
        disp(['EXECUTING: ' command]);
        unix(command);
        
        epi_prefix2 = [epi_prefix '_Tshift'];
        command = ['3dTshift -tpattern @' tpattern_filename ' -TR ' ...
            int2str(TR) 'ms -verbose -prefix ' epi_prefix2 ...
            '.nii.gz ' epi_prefix1 '.nii.gz'];
        disp(['EXECUTING: ' command]);
        unix(command);

        command = ['3drefit -deoblique -xorigin cen -yorigin cen -zorigin cen ' ...
                    epi_prefix2 '.nii.gz'];
        disp(['EXECUTING: ' command]);
        unix(command);
        command = ['3dresample -orient LPI -prefix ' epi_prefix2 ...
                   '-LPI.nii.gz -inset ' epi_prefix2 '.nii.gz'];
        disp(['EXECUTING: ' command]);
        unix(command);
        
        unix(['mv ' epi_prefix2 '-LPI.nii.gz ' epi_prefix '.nii.gz']);
        unix(['gzip ' this_epidir 'IM*dcm']);
        cd(currdir);
    end
    clear d_thisepidir thisepidir;
    
    % Generate mean epi for the first set of epis
    currdir = pwd;
    cd(func_dir);
    mean_prefix = [d_epi(1).name '.nii.gz'];
    command = ['3dTstat -prefix ' anat_dir d(sidx).name '_Mean.nii.gz ' ...
                   mean_prefix];
    disp(['EXECUTING: ' command]);
    unix(command);
    command = ['3dAutomask -prefix ' anat_dir d(sidx).name '_Mask.nii.gz ' ...
                   anat_dir d(sidx).name '_Mean.nii.gz'];
    disp(['EXECUTING: ' command]);
    unix(command);
    if session ~= 1
        unix(['ln -s ' anat_ref_dir epi_mean_ref_prefix ' ' anat_dir]);
        unix(['ln -s ' anat_ref_dir epi_mask_ref_prefix ' ' anat_dir]);
    end
    cd(currdir);
    clear dummy min_idx run_info run_num run_order run_type runidx ulineidx;
end

% Realign EPI images.  Note that 3dvolreg apparently includes an option
% (-tshift) that takes care of slice timing offsets
%
% Problem: ++ WARNING: -tshift used on a dataset with no time-offsets!
% Solution (attempt): use 3dTshift directly PRIOR to de-obliquing

d_possible_fepis = dir([func_dir '*nii.gz']);
count = 0;
for l1 = 1:length(d_possible_fepis)
    adot = find(d_possible_fepis(l1).name == '.');
    % uline = find(d_possible_fepis(l1).name == '_');   % Excludes food_v2 files unnecessarily
    if ~isempty(str2num(d_possible_fepis(l1).name(adot(1)-1)))
        count = count+1;
        d_fepis(count) = d_possible_fepis(l1);
    end
end
% [letter_rows,dummy] = find(isletter(strvcat(d_fepis.name)));
% d_fepis = d_fepis(unique(letter_rows));     % Eliminates ./ and ../ dirs
if isempty(d_fepis)
    nofuncs = 'x';
    while nofuncs ~= 'y' && nofuncs ~= 'n'
        nofuncs = input('*** CAUTION: No functionals to realign.  Continue (y/n) ?  ','s');
    end
    if nofuncs == 'y'
        disp('    --> Skipping realignment & continuing with script.  Watch for errors.');
    else
        disp('    --> Please use ctrl-C to exist program.  Pausing for now.');
        pause;
    end
else
    mean_prefix = [anat_dir d(sidx).name '_Mean.nii.gz'];
    if session ~= 1 && usesession1 == 'y'
         mean_prefix = [anat_dir epi_mean_ref_prefix];
    end
    d_coreg = dir([func_dir '*CoReg.nii.gz']);
    if ~isempty(d_coreg)
        disp(['  Coregistered epis exist in ', func_dir, '.  Skipping-']);
    else
        currdir = pwd;
        cd(func_dir);
        for l1 = 1:length(d_fepis)
            adot = find(d_fepis(l1).name == '.');
            fepi_prefix = d_fepis(l1).name(1:adot(1)-1);
            fepi_file = [func_dir fepi_prefix '.nii.gz'];
            % fepi_tshift_file = [this_fepi_dir fepi_prefix '_Tshift.nii.gz'];
            % tpattern_file = [d(sidx).name '_' d_fepis(l1).name '_tpattern.txt'];
            if exist(fepi_file) ~= 2
                disp(['  No epi ' fepi_file ' at CoReg step.  Skipping to next directory-']);
            else
                % currdir = pwd;
                % cd(this_fepi_dir);
                % load([fepi_prefix '_epiparams.mat']);
                % command = ['3dTshift -tpattern @' tpattern_file ' -TR ' ...
                %     int2str(TR) 'ms -verbose -prefix ' fepi_prefix ...
                %     '_Tshift.nii.gz ' fepi_file];
                % disp(['EXECUTING: ' command]);
                % unix(command);
                command = ['3dvolreg -twodup -verbose -base ' mean_prefix ...
                    ' -maxdisp1D ' fepi_prefix '_MD1D.txt -1Dfile ' fepi_prefix ...
                    '_1D.txt -prefix ' fepi_prefix '_CoReg.nii.gz ' fepi_file];
                disp(['EXECUTING: ' command]);  % The above previously included "-tshift 0"
                unix(command);
            end
        end
        cd(currdir);
    end
end

% Now do some data quality checking.  Based on my review of the Afni
% documents, there will be 3 elements here:  movement parameters (just
% calculated above), 3dToutcount, & 3dTqual.

d_fepis = dir([func_dir '*CoReg.nii.gz']);
% [letter_rows,dummy] = find(isletter(strvcat(d_fepis.name)));
% d_fepis = d_fepis(unique(letter_rows));     % Eliminates ./ and ../ dirs
if isempty(d_fepis)
    nofuncs = 'x';
    while nofuncs ~= 'y' && nofuncs ~= 'n'
        nofuncs = input('*** CAUTION: No coregistered functionals for data quality assessment.  Continue (y/n) ?  ','s');
    end
    if nofuncs == 'y'
        disp('    --> Skipping quality check & continuing with script.  Watch for errors.');
    else
        disp('    --> Please use ctrl-C to exist program.  Pausing for now.');
        pause;
    end
else
    for l1 = 1:length(d_fepis)
        uline = find(d_fepis(l1).name == '_');
        fepi_prefix = d_fepis(l1).name(1:uline(end)-1);
        fepi_coreg_file = [func_dir fepi_prefix '_CoReg.nii.gz'];
        fepi_outcount_file = [func_dir fepi_prefix '_outcount.txt'];
        fepi_qual_file = [func_dir fepi_prefix '_qual.txt'];
        fepi_mvmt_file = [func_dir fepi_prefix '_1D.txt'];
        if exist(fepi_coreg_file) ~= 2
            disp(['  No coregistered epis to quality-check exist in ', func_dir, '.  Skipping-']);
        else
            qual_exist(1) = exist(fepi_outcount_file);
            qual_exist(2) = exist(fepi_qual_file);
            qual_exist(3) = exist(fepi_mvmt_file);
            if prod(qual_exist) ~= 0
                disp(['  All quality-check files exist in ' func_dir '. Skipping-']);
            else
                currdir = pwd;
                cd(func_dir);
                command = ['3dToutcount -automask -range ' fepi_coreg_file ' > ' fepi_outcount_file];
                disp(['EXECUTING: ' command]);
                unix(command);
                command = ['3dTqual -automask -range ' fepi_coreg_file ' > ' fepi_qual_file];
                disp(['EXECUTING: ' command]);
                unix(command);
                cd(currdir);
                
                % Now gather all quality data for display
                datacheck.outcount = load(fepi_outcount_file);
                datacheck.qual = load(fepi_qual_file);
                datacheck.mvmt = load(fepi_mvmt_file);
                figure(1);
                sizexaxis = 0.55;
                s = subplot(4,1,1);
                plot(datacheck.outcount);
                s_posn = get(s,'Position');
                s_posn(3) = sizexaxis;
                set(s,'XLim',[1 size(datacheck.outcount,1)], 'Position', s_posn);
                ylabel('Outlier Count');
                title(['Subject ' d(sidx).name ' ' d_fepis(l1).name]);
                s = subplot(4,1,2);
                plot(datacheck.qual);
                s_posn = get(s,'Position');
                s_posn(3) = sizexaxis;
                set(s,'XLim',[1 size(datacheck.qual,1)], 'Position', s_posn);
                ylabel('1-Corr: Median');
                s = subplot(4,1,3);
                s_posn = get(s,'Position');
                s_posn(3) = sizexaxis;
                plot(datacheck.mvmt(:,1:3));
                set(s,'XLim',[1 size(datacheck.mvmt,1)], 'Position', s_posn);
                ylabel('Rotation (deg)');
                legend('Roll', 'Pitch', 'Yaw', 'Location', 'BestOutside');
                s = subplot(4,1,4);
                plot(datacheck.mvmt(:,4:6));
                s_posn = get(s,'Position');
                s_posn(3) = sizexaxis;
                set(s,'XLim',[1 size(datacheck.mvmt,1)], 'Position', s_posn);
                xlabel('Time');
                ylabel('Translation (mm)');
                legend('Superior', 'Left', 'Posterior', 'Location', 'BestOutside');
                orient(1,'portrait');
                print(1, '-djpeg99', [func_dir fepi_prefix '_datacheck.jpg']);
            end
        end
    end
end

% Smooth EPI images
d_fepis = dir([func_dir '*CoReg.nii.gz']);
if isempty(d_fepis)
    nofuncs = 'x';
    while nofuncs ~= 'y' && nofuncs ~= 'n'
        nofuncs = input('*** CAUTION: No functionals to smooth.  Continue (y/n) ?  ','s');
    end
    if nofuncs == 'y'
        disp('    --> Skipping smoothing & continuing with script.  Watch for errors.');
    else
        disp('    --> Please use ctrl-C to exist program.  Pausing for now.');
        pause;
    end
else
    for l1 = 1:length(d_fepis)
        uline = find(d_fepis(l1).name == '_');
        fepi_prefix = d_fepis(l1).name(1:uline(end)-1);
        fepi_coreg_file = [func_dir fepi_prefix '_CoReg.nii.gz'];
        if exist(fepi_coreg_file) ~= 2
            disp(['  No coregistered epis for smoothing exist in ', func_dir, '.  Skipping-']);
        elseif exist([func_dir fepi_prefix '_Smooth.nii.gz'])
            disp(['  Smoothed epis exist in ' func_dir '. Skipping-']);
        else
            currdir = pwd;
            cd(func_dir);
            command = ['3dmerge -doall -1blur_fwhm 5 -prefix ' fepi_prefix ...
                '_Smooth.nii.gz ' fepi_coreg_file];
            disp(['EXECUTING: ' command]);
            unix(command);
            cd(currdir);
        end
    end
end

% Now align anatomical images with functionals -- ie. put anatomicals in
% same "space" as the functionals.
%
% NB: Since functionals from sessions 2 & 3 may be aligned with
% functionals from session 1, and those functionals should already have had
% the anatomical alignment performed, this step should only need to take
% place for session 1 OR if session 1 is *not* used as a reference.

if session == 1 || usesession1 == 'n'
    align_anat = 'x';
    anat_dir = [subj_dir 'Anatomy/'];
    anat_prefix = [d(sidx).name '_mprage'];

    % if session ~= 1
    %     anat_dir= anat_ref_dir;
    %     adot = find(anat_ref_prefix == '.');
    %     anat_prefix = anat_ref_prefix(1:adot(end-1)-1);
    % end

    anat_filename = [anat_dir, anat_prefix, '.nii.gz'];
    anat_cut_filename = [anat_dir, anat_prefix, '_Cut.nii.gz'];
    anat_align_filename = [anat_dir, anat_prefix, '_AlignEpi.nii.gz'];
    if exist(anat_dir) ~= 7 || exist(anat_filename) ~= 2
        disp('*** No mprage image. Skipping anatomical -> epi realignment. ***');
    else
        if exist(anat_align_filename) ~= 2
            align_anat = 'y';
        else
            disp(['*** CAUTION: The file ', anat_align_filename, ' exists. ***']);
            while align_anat ~= 'y' && align_anat ~= 'n'
                align_anat = input('  Delete previous aligned anatomical image (y/n) ?  ','s');
            end
            if align_anat == 'y'
                unix(['rm ' anat_cut_filename]);
                unix(['rm ' anat_align_filename]);
            end
        end
    end
    if align_anat == 'y'
        currdir = pwd;
        cd(anat_dir);
        command = ['3dZcutup -keep 80 240 -prefix ' anat_prefix '_Cut.nii.gz ' ...
                    anat_prefix '.nii.gz'];
        disp(['EXECUTING: ', command]);
        unix(command);
        command = ['3drefit -deoblique -xorigin cen -yorigin cen -zorigin cen ' ...
                    anat_prefix '_Cut.nii.gz'];
        disp(['EXECUTING: ', command]);
        unix(command);
        command = ['3dresample -orient LPI -prefix ' anat_prefix ...
                    '_Cut_LPI.nii.gz -inset ' anat_prefix '_Cut.nii.gz'];
        disp(['EXECUTING: ', command]);
        unix(command);
        unix(['mv ' anat_prefix '_Cut_LPI.nii.gz ' anat_prefix '_Cut.nii.gz']);
    
        % command = ['lpc_align.py -epi ' d(sidx).name '_Mean.nii.gz ' ...
        %                '-anat ' anat_prefix '_Cut.nii.gz'];
        command = ['align_epi_anat.py -anat ' anat_prefix '_Cut.nii.gz ' ...
                       '-epi ' d(sidx).name '_Mean.nii.gz -epi_base 5 -big_move'];
        disp(['EXECUTING: ', command]);
        unix(command);
        unix(['rename Cut.nii.gz_al AlignEpi *Cut.nii.gz_al*']);
        % unix(['mv ' anat_prefix '_Cut_alepi.nii.gz ' anat_prefix '_AlignEpi.nii.gz']);
        % unix(['mv anat2epi.aff12.1D ' anat_prefix '_Cut_1D.txt']);
        % unix('rm _lpc*');
        cd(currdir);
    end
    clear adir_exist anat_filename anat_prefix convert_anat currdir d_mprage;

    % Now normalize realigned anatomical to the MNI template
    norm_anat = 'x';
    norm_dir = [subj_dir 'Anatomy/'];
    prenorm_prefix = [d(sidx).name '_mprage_AlignEpi'];
    prenorm_filename = [norm_dir prenorm_prefix '.nii.gz'];
    norm_prefix = [d(sidx).name '_mprage_MNI'];
    norm_filename = [norm_dir norm_prefix '.nii.gz'];
    if exist(norm_dir) ~= 7 || exist(prenorm_filename) ~= 2
        disp('*** No EPI-aligned anatomical image. Skipping anatomical -> epi realignment. ***');
    else
        if exist(norm_filename) ~= 2
            norm_anat = 'y';
        else
            disp(['*** CAUTION: The file ', norm_filename, ' exists. ***']);
            while norm_anat ~= 'y' && norm_anat ~= 'n'
                norm_anat = input('  Delete previous normed anatomical image (y/n) ?  ','s');
            end
            if norm_anat == 'y'
                unix(['rm ' norm_filename]);
            end
        end
    end
    if norm_anat == 'y'
        currdir = pwd;
        cd(norm_dir);
        mni_template = [template_dir 'MNI-Brain.nii.gz'];
        omat_file = [d(sidx).name '_flirt.txt'];
        command = ['flirt -ref ' mni_template ' -in ' prenorm_filename ...
                    ' -omat ' omat_file];
        disp(['EXECUTING: ' command]);
        unix(command);
        fnirt_file = [d(sidx).name '_fnirt.nii.gz'];
        config_file = [template_dir 'MNI-Brain.cnf'];
        command = ['fnirt --in=' prenorm_filename ' --aff=' omat_file ...
                    ' --cout=' fnirt_file ' --config=' config_file];
        disp(['EXECUTING: ' command]);
        unix(command);
        command = ['applywarp --ref=' mni_template ' --in=' prenorm_filename ...
                    ' --warp=' fnirt_file ' --out=' norm_filename];
        disp(['EXECUTING: ' command]);
        unix(command);

        % SAMPLE ADDITIONAL COMMANDS:
        %
        % 3dresample -prefix 101/GLM/101-Contrast-AA-Resample.nii.gz -dxyz 3 3 3 -master 101/GLM/101-Brain.nii.gz -inset 101/GL
        % M/101-Contrast-AA.nii.gz
        % 
        % applywarp --ref=MNI/NIfTI/MNI-small.nii --in=101/GLM/101-Contrast-AA-Resample.nii.gz --warp=101/GLM/101-Brain-fnirt.n
        % ii.gz --out=MNI/GLM/101-Contrast-AA-Std.nii.gz
    
        cd(currdir);
    end
end

% Now organize / clean up created files.

disp(' ');
disp('Checking DICOM directories:');
dscout = dir([dicom_dir '*cout_*']);
if isempty(dscout)
    disp('  No extraneous files detected.');
else
    for l1 = 1:length(dscout)
        disp(['    ' dscout(l1).name]);
    end
    dispose = 'x';
    while dispose ~= 'n' && dispose ~= 'y'
        dispose = input('  Would you like to delete these directories (y/n) ?  ','s');
    end
    if dispose == 'y'
        areyousure = 'x';
        while areyousure ~= 'y' && areyousure ~= 'n'
            areyousure = input('  --> Are you sure (y/n) ?  ','s');
        end
        if areyousure == 'y'
            for l1 = 1:length(dscout)
                unix(['rm -R ' dicom_dir dscout(l1).name]);
            end
        end
        clear areyousure;
    end
    clear dispose;

end
clear dscout;

disp('Checking anatomical directory:');
dcut = dir([anat_dir '*Cut*']);
if isempty(dcut)
    disp('  No extraneous files detected.');
else
    for l1 = 1:length(dcut)
        disp(['  ' dcut(l1).name]);
    end
    dispose = 'x';
    while dispose ~= 'n' && dispose ~= 'y'
        dispose = input('  Would you like to delete these files (y/n) ?  ','s');
    end
    if dispose == 'y'
        areyousure = 'x';
        while areyousure ~= 'y' && areyousure ~= 'n'
            areyousure = input('  --> Are you sure (y/n) ?  ','s');
        end
        if areyousure == 'y'
            for l1 = 1:length(dcut)
                unix(['rm ' anat_dir dcut(l1).name]);
            end
        end
        clear areyousure;
    end
    clear dispose;
end
clear dcut;

disp('Checking functional directory:');
dtshift = dir([func_dir '*Tshift.nii.gz']);
if isempty (dtshift)
    disp('  No extraneous files detected.');
else
    for l1 = 1:length(dtshift)
        disp(['  ' dtshift(l1).name]);
    end
    dispose = 'x';
    while dispose ~= 'n' && dispose ~= 'y'
        dispose = input('  Would you like to delete these files (y/n) ?  ','s');
    end
    if dispose == 'y'
        areyousure = 'x';
        while areyousure ~= 'y' && areyousure ~= 'n'
            areyousure = input('  --> Are you sure (y/n) ?  ','s');
        end
        if areyousure == 'y'
            for l1 = 1:length(dtshift)
                unix(['rm ' func_dir dtshift(l1).name]);
            end
        end
        clear areyousure;
    end
    clear dispose;
end
clear dtshift;

disp('Organizing functional directory:');
if exist([func_dir 'datacheck']) ~= 7
    unix(['mkdir ' func_dir 'datacheck/']);
    unix(['mv ' func_dir '*datacheck.jpg ' func_dir 'datacheck/']);
    unix(['mv ' func_dir '*.txt ' func_dir 'datacheck/']);
else
    disp('  datacheck directory exists; no action taken.');
end
if exist([func_dir 'food']) ~= 7
    unix(['mkdir ' func_dir 'food/']);
    unix(['mv ' func_dir '*_food_* ' func_dir 'food/']);
else
    disp('  food directory exists; no action taken.');
end
if exist([func_dir 'ddt']) ~= 7
    unix(['mkdir ' func_dir 'ddt/']);
    unix(['mv ' func_dir '*_ddt_* ' func_dir 'ddt/']);
else
    disp('  ddt directory exists; no action taken.');
end
if exist([func_dir 'rest']) ~= 7
    unix(['mkdir ' func_dir 'rest/']);
    unix(['mv ' func_dir '*_rest_* ' func_dir 'rest/']);
else
    disp('  rest directory exists; no action taken.');
end

diary off;


